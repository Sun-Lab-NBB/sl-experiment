import numpy as np
from numpy.typing import NDArray as NDArray
from ataraxis_time import PrecisionTimer
from sl_shared_assets import (
    SessionData,
    RunTrainingDescriptor,
    LickTrainingDescriptor,
    MesoscopeExperimentDescriptor,
    MesoscopeExperimentConfiguration,
)
from ataraxis_data_structures import DataLogger, SharedMemoryArray
from ataraxis_communication_interface import MQTTCommunication

from .tools import (
    MesoscopeData as MesoscopeData,
    RuntimeControlUI as RuntimeControlUI,
    get_system_configuration as get_system_configuration,
)
from .visualizers import BehaviorVisualizer as BehaviorVisualizer
from .binding_classes import (
    ZaberMotors as ZaberMotors,
    VideoSystems as VideoSystems,
    MicroControllerInterfaces as MicroControllerInterfaces,
)
from ..shared_components import (
    WaterSheet as WaterSheet,
    SurgerySheet as SurgerySheet,
    BreakInterface as BreakInterface,
    ValveInterface as ValveInterface,
    write_version_data as write_version_data,
)
from .data_preprocessing import (
    purge_failed_session as purge_failed_session,
    preprocess_session_data as preprocess_session_data,
)

class _MesoscopeExperiment:
    """The base class for all Mesoscope-VR experiment runtimes.

    This class provides methods for conducting experiments using the Mesoscope-VR system. It abstracts most
    low-level interactions with the VR system and the mesoscope via a simple high-level state API.

    Notes:
        Calling this initializer only instantiates a minimal subset of all Mesoscope-VR assets. Use the start() method
        before issuing other commands to properly initialize all required runtime assets and remote processes.

        This class statically reserves the id code '1' to label its log entries. Make sure no other Ataraxis class, such
        as MicroControllerInterface or VideoSystem, uses this id code.

    Args:
        experiment_configuration: An initialized MesoscopeExperimentConfiguration instance that specifies experiment
            configuration and state sequence.
        session_data: An initialized SessionData instance used to control the flow of data during acquisition.
        session_descriptor: A partially initialized MesoscopeExperimentDescriptor instance. This instance is used to
            store session-specific information in a human-readable format.

    Attributes:
        _state_map: Maps the integer state-codes used to represent VR system states to human-readable string-names.
        _started: Tracks whether the VR system and experiment runtime are currently running.
        descriptor: Stores the session descriptor instance of the managed session.
        _experiment_configuration: Stores the MesoscopeExperimentConfiguration instance of the managed session.
        _session_data: Stores the SessionData instance of the managed session.
        _mesoscope_data: Stores the MesoscopeData instance of the managed session.
        vr_state: Stores the current state of the VR system. The MesoscopeExperiment updates this value whenever it is
            instructed to change the VR system state.
        _experiment_state: Stores the user-defined experiment state. Experiment states are defined by the user and
            are expected to have unique meaning for each project and, potentially, experiment.
        _source_id: Stores the unique identifier code for this class instance. The identifier is used to mark log
            entries made by this class instance and has to be unique across all sources that log data at the same time,
            such as MicroControllerInterfaces and VideoSystems.
        _timestamp_timer: A PrecisionTimer instance used to timestamp log entries generated by the class instance.
        _previous_position: Stores the absolute position of the animal, in Unity units, used during the last
            communication cycle between this class and Unity.
        _previous_licks: Stores the number of detected licks, used during the last communication cycle between this
            class and Unity.
        _cue_sequence: Stores the Virtual Reality wall cue sequence used by the currently active Unity VR runtime.
        _unconsumed_count: Tracks the number of rewards delivered to the animal without the animal consuming them.
        _unity_termination_topic: Stores the MQTT topic used by Unity game engine to announce when it terminates the
            game state.
        _cue_sequence_topic: Stores the MQTT topic used by Unity game engine to respond to the request of the VR wall
            cue sequence.
        _cue_sequence_request_topic: Stores the MQTT topic which can be used to request the Unity task to send the
            sequence of wall cues used during runtime to the cue sequence MQTT topic.
        _disable_guidance_topic: Stores the MQTT topic used to switch the virtual task into unguided mode (sets
            'must lick' to true).
        _enable_guidance_topic: Stores the MQTT topic used to switch the virtual task into guided mode (sets
            'must lick' to false).
        unity_terminated: Tracks whether a termination message has been received from Unity.
        _logger: A DataLogger instance that collects behavior log data from all sources: microcontrollers, video
            cameras, and the MesoscopeExperiment instance.
        _microcontrollers: Stores the MicroControllerInterfaces instance that interfaces with all MicroController
            devices used during runtime.
        _cameras: Stores the VideoSystems instance that interfaces with video systems (cameras) used during
            runtime.
        _zaber_motors: Stores the ZaberMotors class instance that interfaces with HeadBar, LickPort, and Wheel motors.
    """

    _state_map: dict[int, str]
    _started: bool
    descriptor: MesoscopeExperimentDescriptor
    _experiment_configuration: MesoscopeExperimentConfiguration
    _session_data: SessionData
    _mesoscope_data: MesoscopeData
    vr_state: int
    _experiment_state: int
    _source_id: np.uint8
    _timestamp_timer: PrecisionTimer
    _previous_position: float
    _previous_licks: int
    _cue_sequence: NDArray[np.uint8]
    _unconsumed_count: int
    unity_terminated: bool
    _unity_termination_topic: str
    _cue_sequence_topic: str
    _cue_sequence_request_topic: str
    _disable_guidance_topic: str
    _enable_guidance_topic: str
    _logger: DataLogger
    _microcontrollers: MicroControllerInterfaces
    _unity: MQTTCommunication
    _cameras: VideoSystems
    _zaber_motors: ZaberMotors
    def __init__(
        self,
        experiment_configuration: MesoscopeExperimentConfiguration,
        session_data: SessionData,
        session_descriptor: MesoscopeExperimentDescriptor,
    ) -> None: ...
    def start(self) -> None:
        """Initializes and configures all assets used during the experiment.

        This internal method establishes the communication with the microcontrollers, data logger cores, and video
        system processes. It also requests the cue sequence from Unity game engine. Critically, it does NOT start the
        experiment runtime. Use start_experiment() method to transition into experiment runtime mode.

        Notes:
            This method will not run unless the host PC has access to the necessary number of logical CPU cores
            and other required hardware resources (GPU for video encoding, etc.). This prevents using the class on
            machines that are unlikely to sustain the runtime requirements.

            As part of its runtime, this method will attempt to set all Zaber motors to the positions optimal for
            mesoscope frame acquisition. Exercise caution and always monitor the system when it is running this method,
            as unexpected motor behavior can damage the mesoscope or harm the animal.

        Raises:
            RuntimeError: If the host PC does not have enough logical CPU cores available.
        """
    def stop(self) -> None:
        """Stops and terminates all Mesoscope-VR components and ends the experiment runtime.

        This method achieves two main purposes. First, it releases the hardware resources used during the experiment
        runtime by various system components. Second, it pulls all collected data to the VRPC and runs the preprocessing
        pipeline on the data to prepare it for long-term storage and further processing.
        """
    def rest(self) -> None:
        """Switches the Mesoscope-VR system to the rest state.

        In the rest state, the break is engaged to prevent the mouse from moving the wheel. The encoder module is
        disabled, and instead the torque sensor is enabled. The VR screens are switched off, cutting off light emission.
        By default, the VR system starts all experimental runtimes using the REST state.

        Notes:
            Rest Mesoscope-VR state is hardcoded as '1'.
        """
    def run(self) -> None:
        """Switches the Mesoscope-VR system to the run state.

        In the run state, the break is disengaged to allow the mouse to freely move the wheel. The encoder module is
        enabled to record and share live running data with Unity, and the torque sensor is disabled. The VR screens are
        switched on to render the VR environment.

        Notes:
            Run Mesoscope-VR state is hardcoded as '2'.
        """
    def idle(self) -> None:
        """Switches the Mesoscope-VR system to the idle state.

        In the idle state, the break is engaged to prevent the animal from moving the wheel and the screens are turned
        off. Both torque and encoder monitoring is disabled. Note, idle state is designed to be used exclusively when
        the user requests the runtime to be paused for any reason.

        Notes:
            Unlike the other VR states, setting the system to 'Idle' also automatically changes the experiment state to
            0 (idle).

            Idle Mesoscope-VR state is hardcoded as '0'.
        """
    def deliver_reward(self, reward_size: float = 5.0) -> None:
        """Uses the solenoid valve to deliver the requested volume of water in microliters.

        This method is used by the experiment runtime logic to allow the experimenter to manually deliver water to the
        animal.
        """
    def simulate_reward(self) -> None:
        """Uses the buzzer controlled by the valve module to deliver an audible tone without delivering any water.

        This method is used when the animal refuses to consume water rewards. The tone notifies the animal that it
        performs the experiment as expected, while simultaneously minimizing water reward wasting. Primarily, this is
        helpful for experiments that run in the guided mode.
        """
    def configure_reward_parameters(self, reward_size: float = 5.0, tone_duration: int = 300) -> None:
        """Configures all future water rewards to use the provided reward size (volume) and tone duration parameters.

        Primarily, this function is used to reconfigure the system from GUI and trigger reward delivery from Unity.

        Args:
            reward_size: The volume of water to deliver, in microliters.
            tone_duration: The duration of the auditory tone, in milliseconds, to emit while delivering the water
                reward.
        """
    def toggle_valve(self, state: bool) -> None:
        """Configures the valve to match the input state.

        Args:
            state: The state to set the valve to. Setting this to True opens the valve, setting this to False closes
                the valve.
        """
    def get_cue_sequence(self) -> None:
        """Requests Unity game engine to transmit the sequence of virtual reality track wall cues for the current task.

        This method is used as part of the experimental runtime startup process to both get the sequence of cues and
        verify that the Unity game engine is running and configured correctly. It is also reused as part of the process
        for recovering from Unity failures to re-initialize and re-synchronize the runtime with the VR state.

        Notes:
            This method contains an infinite loop that allows retrying the failed connection. This prevents the runtime
            from aborting unless the user purposefully chooses the hard abort option.

            Upon receiving the cue sequence data, the method caches the data into the private _cue_sequence class
            attribute. The attribute is then used to handle certain types of teleport events during runtime.

        Raises:
            RuntimeError: If Unity sends a message to an unexpected (different) topic other than "CueSequence/" while
                this method is running. Also, if the user chooses to abort the runtime if the method does not receive a
                response from Unity in 2 seconds.
        """
    def _check_unity(self) -> None:
        """Pauses runtime until Unity sends a termination message and instructs the user to check that the task displays
        on the VR screens as intended.

        This method is used to ensure that the user starts and stops Unity game engine at least once. This is used to
        force each user to check that their virtual task properly displays on the VR screens.

        Notes:
            This method contains an infinite loop that forces the user to cycle through Unity game state or manually
            abort the runtime.
        """
    def start_mesoscope(self) -> None:
        """Sends the frame acquisition start TTL pulse to the mesoscope and waits for the frame acquisition to begin.

        This method is used internally to start the mesoscope frame acquisition as part of the experiment startup
        process. It is also used to verify that the mesoscope is available and properly configured to acquire frames
        based on the input triggers.

        Notes:
            This method contains an infinite loop that allows retrying the failed mesoscope acquisition start. This
            prevents the runtime from aborting unless the user purposefully chooses the hard abort option.

        Raises:
            RuntimeError: If the mesoscope does not confirm frame acquisition within 2 seconds after the
                acquisition trigger is sent and the user chooses to abort the runtime.
        """
    def _change_vr_state(self, new_state: int) -> None:
        """Updates and logs the new Mesoscope-VR state.

        This method is used internally to timestamp and log VR state (stage) changes, such as transitioning between
        rest and run VR states.

        Args:
            new_state: The byte-code for the newly activated VR state.
        """
    def change_experiment_state(self, new_state: int) -> None:
        """Updates and logs the new experiment state.

        Use this method to timestamp and log experiment state (stage) changes, such as transitioning between different
        task goals.

        Args:
            new_state: The integer byte-code for the new experiment state. The code will be serialized as an uint8
                value, so only values between 0 and 255 inclusive are supported.
        """
    def toggle_lick_guidance(self, enable_guidance: bool) -> None:
        """Sets the Unity task to either require the animal to lick in the reward zone to get water or to get rewards
        automatically upon entry into the reward zone.

        Notes:
            The boolean 'enable guidance' state is an inverse of the Unities 'must lick' toggle. Therefore, if
            guidance is True, Must Lick is False.

        Args:
            enable_guidance: Determines whether the animal must lick (False) to get water rewards or whether it will
                receive rewards automatically when entering the zone (True).
        """
    @property
    def trackers(self) -> tuple[SharedMemoryArray, SharedMemoryArray, SharedMemoryArray]:
        """Returns the tracker SharedMemoryArrays for (in this order) the LickInterface, ValveInterface, and
        EncoderInterface.

        These arrays should be passed to the BehaviorVisualizer class to monitor the lick, valve and running speed data
        in real time during the experiment session.
        """
    def communicate_with_unity(self) -> None:
        """Handles bidirectional communication between the Virtual Reality task in Unity and the main runtime logic and
        hardware module interfaces in Python.

        The VR system broadly consists of two components: Unity game engine (virtual task) and a set of microcontrollers
        managing the physical task environment. This function sends the data expected by Unity to the virtual reality
        and receives and executes commands sent by Unity to the microcontrollers. To do so, it leverages the
        MQTTCommunication class and acts as a persistent bidirectional interface between Unity and the rest of the
        Mesoscope-VR system.

        Notes:
            This method has been introduced in version 2.0.0 to aggregate all Unity communication (via MQTT) at the
            highest level of the runtime hierarchy (the main runtime management class). This prevents an error with the
            Mosquitto MQTT broker, where the broker arbitrarily disconnects clients running in remote processes.

            During runtime, this method attempts to receive data from Unity. During each runtime cycle, the method
            receives and parses exactly one message stored in the MQTTCommunication class buffer. Also, as part of each
            cycle the method sends updated distance and lick data to Unity.
        """

class _BehaviorTraining:
    """The base class for all Mesoscope-VR behavior training runtimes.

    This class provides methods for running the lick and run training sessions using a subset of the Mesoscope-VR
    system. It abstracts most low-level interactions with the VR system and the mesoscope via a simple
    high-level state API.

    Notes:
        Calling this initializer only instantiates a minimal subset of all Mesoscope-VR assets. Use the start() method
        before issuing other commands to properly initialize all required runtime assets and remote processes.

    Args:
        session_data: An initialized SessionData instance used to control the flow of data during acquisition and
            preprocessing. Each instance is initialized for the specific project, animal, and session combination for
            which the data is acquired.
        session_descriptor: A partially initialized LickTrainingDescriptor or RunTrainingDescriptor instance. This
            instance is used to store session-specific information in a human-readable format.

    Attributes:
        _started: Tracks whether the VR system and training runtime are currently running.
        _source_id: Stores the unique identifier code for this class instance. The identifier is used to mark log
            entries made by this class instance and has to be unique across all sources that log data at the same time,
            such as MicroControllerInterfaces and VideoSystems.
        _timestamp_timer: A PrecisionTimer instance used to timestamp log entries generated by the class instance.
        _hardware_state_saved: Tracks whether the instance has cached the HardwareState instance to disk. Since this
            is done as part of configuring system runtime state, this tracker is used to limit the caching to only
            happen once per each runtime.
        descriptor: Stores the session descriptor instance of the managed session.
        _session_data: Stores the SessionData instance of the managed session.
        _mesoscope_data: Stores the MesoscopeData instance of the managed session.
        _logger: A DataLogger instance that collects behavior log data from all sources: microcontrollers and video
            cameras.
        _microcontrollers: Stores the MicroControllerInterfaces instance that interfaces with all MicroController
            devices used during runtime.
        _cameras: Stores the VideoSystems instance that interfaces with video systems (cameras) used during
            runtime.
        _zaber_motors: Stores the ZaberMotors class instance that interfaces with HeadBar, LickPort, and Wheel motors.
    """

    _started: bool
    _source_id: np.uint8
    _timestamp_timer: PrecisionTimer
    _hardware_state_saved: bool
    descriptor: LickTrainingDescriptor | RunTrainingDescriptor
    _session_data: SessionData
    _mesoscope_data: MesoscopeData
    _logger: DataLogger
    _microcontrollers: MicroControllerInterfaces
    _cameras: VideoSystems
    _zaber_motors: ZaberMotors
    def __init__(
        self, session_data: SessionData, session_descriptor: LickTrainingDescriptor | RunTrainingDescriptor
    ) -> None: ...
    def start(self) -> None:
        """Initializes and configures all assets used during the behavior training.

        This internal method establishes the communication with the microcontrollers, data logger cores, and video
        system processes.

        Notes:
            This method will not run unless the host PC has access to the necessary number of logical CPU cores
            and other required hardware resources (GPU for video encoding, etc.). This prevents using the class on
            machines that are unlikely to sustain the runtime requirements.

            As part of its runtime, this method will attempt to set all Zaber motors to the positions that facilitate
            the training and future experiment sessions. Exercise caution and always monitor the system when it is
            running this method, as unexpected motor behavior can damage the mesoscope or harm the animal.

            Unlike the experiment class start(), this method does not preset the hardware module states during runtime.
            Call the desired training state method to configure the hardware modules appropriately for the chosen
            runtime mode.

        Raises:
            RuntimeError: If the host PC does not have enough logical CPU cores available.
        """
    def stop(self) -> None:
        """Stops and terminates all Mesoscope-VR components and ends the behavior training runtime.

        This method achieves two main purposes. First, it releases the hardware resources used during the training
        runtime by various system components. Second, it runs the preprocessing pipeline on the data to prepare it for
        long-term storage and further processing.
        """
    def lick_train(self) -> None:
        """Configures the Mesoscope-VR system for running the lick training.

        In this state, the break is engaged to prevent the mouse from moving the wheel. The encoder module is
        disabled, and the torque sensor is enabled. The VR screens are switched off, cutting off light emission.
        The lick sensor monitoring is on to record animal licking data.

        Notes:
            Calling this method automatically switches the 'experiment state' to 255 to indicate active runtime.
        """
    def run_train(self) -> None:
        """Configures the Mesoscope-VR system for running the run training.

        In this state, the break is disengaged, allowing the mouse to run on the wheel. The encoder module is
        enabled, and the torque sensor is disabled. The VR screens are switched off, cutting off light emission.
        The lick sensor monitoring is on to record animal licking data.

        Notes:
            Calling this method automatically switches the 'experiment state' to 255 to indicate active runtime.
        """
    def idle(self) -> None:
        """Switches the Mesoscope-VR system to the idle state.

        In the idle state, the break is engaged to prevent the animal from moving the wheel and sensor monitoring is
        disabled. This state is designed to be used exclusively during 'pause' periods to prevent generating aberrant
        data.

        Notes:
            When this method is called, it automatically switches the ongoing 'experiment state' to 0 to indicate the
            pause epoch.

            Idle Mesoscope-VR state is hardcoded as '0'.
        """
    def _change_vr_state(self, new_state: int) -> None:
        """Updates and logs the new Mesoscope-VR state.

        This method is used internally to timestamp and log VR state (stage) changes, such as transitioning between
        the paused and the training states.

        Args:
            new_state: The byte-code for the newly activated VR state.
        """
    def _change_experiment_state(self, new_state: int) -> None:
        """Updates and logs the new experiment state.

        Unlike a similar method for the MesoscopeExperiment class, this class is designed to only use two experiment
        states: 0 (paused) and 255 (active).

        Args:
            new_state: The integer byte-code for the new experiment state. The code will be serialized as an uint8
                value, so only values between 0 and 255 inclusive are supported.
        """
    def deliver_reward(self, reward_size: float = 5.0) -> None:
        """Uses the solenoid valve to deliver the requested volume of water in microliters.

        This method is used by the training runtimes to reward the animal with water as part of the training process.
        """
    def configure_reward_parameters(self, reward_size: float = 5.0, tone_duration: int = 300) -> None:
        """Configures all future water rewards to use the provided reward size (volume) and tone duration parameters.

        Primarily, this function is used to reconfigure the system from GUI and trigger reward delivery from Unity.

        Args:
            reward_size: The volume of water to deliver, in microliters.
            tone_duration: The duration of the auditory tone, in milliseconds, to emit while delivering the water
                reward.
        """
    def toggle_valve(self, state: bool) -> None:
        """Configures the valve to match the input state.

        Args:
            state: The state to set the valve to. Setting this to True opens the valve, setting this to False closes
                the valve.
        """
    def simulate_reward(self) -> None:
        """Uses the buzzer controlled by the valve module to deliver an audible tone without delivering any water.

        This method is used by the training runtimes when the animal refuses to consume water rewards. The tone notifies
        the animal that it performs the training as expected, while simultaneously minimizing water reward wasting.
        """
    @property
    def trackers(self) -> tuple[SharedMemoryArray, SharedMemoryArray, SharedMemoryArray]:
        """Returns the tracker SharedMemoryArrays for (in this order) the LickInterface, ValveInterface, and
        EncoderInterface.

        These arrays should be passed to the BehaviorVisualizer class to monitor the lick, valve and running speed data
        in real time during training.
        """

def lick_training_logic(
    experimenter: str,
    project_name: str,
    animal_id: str,
    animal_weight: float,
    minimum_reward_delay: int = 6,
    maximum_reward_delay: int = 18,
    maximum_water_volume: float = 1.0,
    maximum_training_time: int = 20,
    maximum_unconsumed_rewards: int = 1,
    load_previous_parameters: bool = False,
) -> None:
    """Encapsulates the logic used to train animals to operate the lick port.

    The lick training consists of delivering randomly spaced 5 uL water rewards via the solenoid valve to teach the
    animal that water comes out of the lick port. Each reward is delivered after a pseudorandom delay. Reward delay
    sequence is generated before training runtime by sampling a uniform distribution that ranges from
    'minimum_reward_delay' to 'maximum_reward_delay'. The training continues either until the valve
    delivers the 'maximum_water_volume' in milliliters or until the 'maximum_training_time' in minutes is reached,
    whichever comes first.

    Args:
        experimenter: The ID (net-ID) of the experimenter conducting the training.
        project_name: The name of the project to which the trained animal belongs.
        animal_id: The numeric ID of the animal being trained.
        animal_weight: The weight of the animal, in grams, at the beginning of the training session.
        minimum_reward_delay: The minimum time, in seconds, that has to pass between delivering two consecutive rewards.
        maximum_reward_delay: The maximum time, in seconds, that can pass between delivering two consecutive rewards.
        maximum_water_volume: The maximum volume of water, in milliliters, that can be delivered during this runtime.
        maximum_training_time: The maximum time, in minutes, to run the training.
        maximum_unconsumed_rewards: The maximum number of rewards that can be delivered without the animal consuming
            them, before reward delivery (but not the training!) pauses until the animal consumes available rewards.
            If this is set to a value below 1, the unconsumed reward limit will not be enforced. A value of 1 means
            the animal has to consume each reward before getting the next reward.
        load_previous_parameters: Determines whether to override all input runtime-defining parameters with the
            parameters used during the previous session. If this is set to True, the function will ignore most input
            parameters and will instead load them from the cached session descriptor of the previous session. If the
            descriptor is not available, the function will fall back to using input parameters.
    """

def run_training_logic(
    experimenter: str,
    project_name: str,
    animal_id: str,
    animal_weight: float,
    initial_speed_threshold: float = 0.5,
    initial_duration_threshold: float = 0.5,
    speed_increase_step: float = 0.05,
    duration_increase_step: float = 0.05,
    increase_threshold: float = 0.1,
    maximum_water_volume: float = 1.0,
    maximum_training_time: int = 40,
    maximum_idle_time: float = 0.5,
    maximum_unconsumed_rewards: int = 1,
    load_previous_parameters: bool = False,
) -> None:
    """Encapsulates the logic used to train animals to run on the wheel treadmill while being head-fixed.

    The run training consists of making the animal run on the wheel with a desired speed, in centimeters per second,
    maintained for the desired duration of time, in seconds. Each time the animal satisfies the speed and duration
    thresholds, it receives 5 uL of water reward, and the speed and durations trackers reset for the next training
    'epoch'. Each time the animal receives 'increase_threshold' of water, the speed and duration thresholds increase to
    make the task progressively more challenging. The training continues either until the training time exceeds the
    'maximum_training_time', or the animal receives the 'maximum_water_volume' of water, whichever happens earlier.

    Args:
        experimenter: The id of the experimenter conducting the training.
        project_name: The name of the project to which the trained animal belongs.
        animal_id: The numeric ID of the animal being trained.
        animal_weight: The weight of the animal, in grams, at the beginning of the training session.
        initial_speed_threshold: The initial running speed threshold, in centimeters per second, that the animal must
            maintain to receive water rewards.
        initial_duration_threshold: The initial duration threshold, in seconds, that the animal must maintain
            above-threshold running speed to receive water rewards.
        speed_increase_step: The step size, in centimeters per second, by which to increase the speed threshold each
            time the animal receives 'increase_threshold' milliliters of water.
        duration_increase_step: The step size, in seconds, by which to increase the duration threshold each time the
            animal receives 'increase_threshold' milliliters of water.
        increase_threshold: The volume of water received by the animal, in milliliters, after which the speed and
            duration thresholds are increased by one step. Note, the animal will at most get 'maximum_water_volume' of
            water, so this parameter effectively controls how many increases will be made during runtime, assuming the
            maximum training time is not reached.
        maximum_water_volume: The maximum volume of water, in milliliters, that can be delivered during this runtime.
        maximum_training_time: The maximum time, in minutes, to run the training.
        maximum_idle_time: The maximum time, in seconds, the animal's speed can be below the speed threshold to
            still receive water rewards. This parameter is designed to help animals with a distinct 'step' pattern to
            not lose water rewards due to taking many large steps, rather than continuously running at a stable speed.
            This parameter allows the speed to dip below the threshold for at most this number of seconds, for the
            'running epoch' to not be interrupted.
        maximum_unconsumed_rewards: The maximum number of rewards that can be delivered without the animal consuming
            them, before reward delivery (but not the training!) pauses until the animal consumes available rewards.
            If this is set to a value below 1, the unconsumed reward limit will not be enforced. A value of 1 means
            the animal has to consume all rewards before getting the next reward.
        load_previous_parameters: Determines whether to override all input runtime-defining parameters with the
            parameters used during the previous session. If this is set to True, the function will ignore most input
            parameters and will instead load them from the cached session descriptor of the previous session. If the
            descriptor is not available, the function will fall back to using input parameters.
    """

def experiment_logic(
    experimenter: str,
    project_name: str,
    experiment_name: str,
    animal_id: str,
    animal_weight: float,
    maximum_unconsumed_rewards: int = 1,
) -> None:
    """Encapsulates the logic used to run experiments via the Mesoscope-VR system.

    This function can be used to execute any valid experiment using the Mesoscope-VR system. Each experiment should be
    broken into one or more experiment states (phases), such as 'baseline', 'task' and 'cooldown'. Furthermore, each
    experiment state can use one or more VR system states. Currently, the VR system has two states: rest (1) and run
    (2). The states are used to broadly configure the Mesoscope-VR system, and they determine which systems are active
    and what data is collected (see library ReadMe for more details on VR states).

    Primarily, this function is concerned with iterating over the states stored inside the experiment_state_sequence
    tuple. Each experiment and VR state combination is maintained for the requested duration of seconds. Once all states
    have been executed, the experiment runtime ends. Under this design pattern, each experiment is conceptualized as
    a sequence of states.

    Notes:
        During experiment runtimes, the task logic and the Virtual Reality world are resolved via the Unity game engine.
        This function itself does not resolve the task logic, it is only concerned with iterating over experiment
        states, controlling the VR system, and monitoring user command issued via keyboard.

        Similar to all other runtime functions, this function contains all necessary bindings to set up, execute, and
        terminate an experiment runtime. Custom projects should implement a cli that calls this function with
        project-specific parameters.

    Args:
        experimenter: The id of the experimenter conducting the experiment.
        project_name: The name of the project for which the experiment is conducted.
        experiment_name: The name or ID of the experiment to be conducted.
        animal_id: The numeric ID of the animal participating in the experiment.
        animal_weight: The weight of the animal, in grams, at the beginning of the experiment session.
        maximum_unconsumed_rewards: The maximum number of rewards that can be delivered without the animal consuming
            them, before reward delivery (but not the experiment!) pauses until the animal consumes available rewards.
            If this is set to a value below 1, the unconsumed reward limit will not be enforced. A value of 1 means
            the animal has to consume each reward before getting the next reward.
    """

def maintenance_logic() -> None:
    """Encapsulates the logic used to maintain various components of the Mesoscope-VR system.

    This runtime is primarily used to verify and, if necessary, recalibrate the water valve between training or
    experiment days and to maintain the surface material of the running wheel.
    """

def window_checking_logic(project_name: str, animal_id: str) -> None:
    """Encapsulates the logic used to verify the surgery quality (cranial window) and generate the initial snapshot of
    the Mesoscope-VR system configuration for a newly added animal of the target project.

    This function is used when new animals are added to the project, before any other training or experiment runtime.
    Primarily, it is used to verify that the surgery went as expected and the animal is fit for providing high-quality
    scientific data. As part of this process, the function also generates the snapshot of zaber motor positions and the
    mesoscope objective position to be reused by future sessions.

    Notes:
        This function largely behaves similar to all other training and experiment session runtimes. However, it does
        not use most of the Mesoscope-VR components and does not make most of the runtime data files typically generated
        by other sessions. All window checking sessions are automatically marked as 'incomplete' and excluded from
        automated data processing.

    Args:
        project_name: The name of the project to which the checked animal belongs.
        animal_id: The numeric ID of the animal whose cranial window is being checked.
    """
