from typing import Any
from dataclasses import field, dataclass
from collections.abc import Callable as Callable

from _typeshed import Incomplete
from ataraxis_time import PrecisionTimer
from zaber_motion.ascii import (
    Axis as Axis,
    Device as Device,
    Connection,
)

@dataclass
class _ZaberAxisData:
    axis_id: int
    axis_label: str

@dataclass
class _ZaberDeviceData:
    device_number: int
    device_id: int
    label: str
    name: str
    axes: list[_ZaberAxisData] = field(default_factory=list)

@dataclass
class _ZaberPortData:
    port_name: str
    devices: list[_ZaberDeviceData] = field(default_factory=list)
    @property
    def has_devices(self) -> bool: ...

@dataclass(frozen=True)
class ZaberDeviceSettings:
    device_label: str
    axis_label: str
    checksum: int
    shutdown_flag: int
    unsafe_flag: int
    park_position: int
    maintenance_position: int
    mount_position: int
    limit_min: float
    limit_max: float
    current_position: float

@dataclass(frozen=True)
class ZaberValidationResult:
    is_valid: bool
    checksum_valid: bool
    positions_valid: bool
    errors: tuple[str, ...]
    warnings: tuple[str, ...]

def _attempt_connection(port: str) -> list[_ZaberDeviceData]: ...
def _scan_active_ports() -> list[_ZaberPortData]: ...
def _format_device_info(port_info_list: list[_ZaberPortData]) -> str: ...
def discover_zaber_devices() -> None: ...
def get_zaber_devices_info() -> str: ...
def get_zaber_device_settings(port: str, device_index: int) -> ZaberDeviceSettings: ...
def set_zaber_device_setting(port: str, device_index: int, setting: str, value: int | str) -> str: ...
def validate_zaber_device_configuration(port: str, device_index: int) -> ZaberValidationResult: ...

class CRCCalculator:
    _calculator: Incomplete
    def __init__(self) -> None: ...
    def string_checksum(self, string: str) -> int: ...

_crc_calculator: Incomplete

@dataclass(frozen=True)
class _ZaberSettings:
    maximum_limit: str = ...
    minimum_limit: str = ...
    position: str = ...
    checksum: str = ...
    shutdown_flag: str = ...
    unsafe_flag: str = ...
    axis_park_position: str = ...
    axis_maintenance_position: str = ...
    axis_mount_position: str = ...

class ZaberAxis:
    _COMMUNICATION_DELAY_MS: int
    _shutdown_flag: bool
    _motor: Axis
    _park_position: int
    _maintenance_position: int
    _mount_position: int
    _maximum_limit: float
    _minimum_limit: float
    _timer: PrecisionTimer
    def __init__(self, motor: Axis) -> None: ...
    def __repr__(self) -> str: ...
    def _padded_method_call(self, method: Callable, *args: Any, **kwargs: Any) -> Any: ...
    def get_position(self) -> float: ...
    @property
    def is_homed(self) -> bool: ...
    @property
    def is_parked(self) -> bool: ...
    @property
    def is_busy(self) -> bool: ...
    @property
    def park_position(self) -> int: ...
    @property
    def maintenance_position(self) -> int: ...
    @property
    def mount_position(self) -> int: ...
    def home(self) -> None: ...
    def move(self, position: int) -> None: ...
    def stop(self) -> None: ...
    def park(self) -> None: ...
    def unpark(self) -> None: ...
    def shutdown(self) -> None: ...

class ZaberDevice:
    _controller: Device
    _axis: ZaberAxis
    _shutdown_flag: bool
    def __init__(self, device: Device) -> None: ...
    def __repr__(self) -> str: ...
    def shutdown(self) -> None: ...
    @property
    def axis(self) -> ZaberAxis: ...

class ZaberConnection:
    _port: str
    _connection: Connection | None
    _devices: tuple[ZaberDevice, ...]
    _is_connected: bool
    def __init__(self, port: str) -> None: ...
    def __repr__(self) -> str: ...
    def __del__(self) -> None: ...
    def connect(self) -> None: ...
    def disconnect(self) -> None: ...
    @property
    def is_connected(self) -> bool: ...
    def get_device(self, index: int) -> ZaberDevice: ...
