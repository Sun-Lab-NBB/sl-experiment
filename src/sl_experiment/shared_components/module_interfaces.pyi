import numpy as np
from _typeshed import Incomplete
from numpy.typing import NDArray as NDArray
from ataraxis_time import PrecisionTimer
from ataraxis_data_structures import SharedMemoryArray
from ataraxis_communication_interface import (
    ModuleData as ModuleData,
    ModuleState as ModuleState,
    ModuleInterface,
)

_ZERO_UINT64: Incomplete
_ZERO_FLOAT64: Incomplete
_ZERO_UINT32: Incomplete
_FALSE: np.bool_
_MAXIMUM_VALVE_PULSE_DURATION_MS: int
_MAXIMUM_VALVE_PULSE_DURATION_US: int
_MAXIMUM_BRAKING_STRENGTH: np.uint8

def _power_law_model(
    pulse_duration: float | NDArray[np.float64], a: float, b: float, /
) -> float | NDArray[np.float64]: ...

class EncoderInterface(ModuleInterface):
    _ppr: int
    _wheel_diameter: float
    _cm_per_pulse: np.float64
    _unity_unit_per_pulse: np.float64
    _polling_frequency: np.uint32
    _distance_tracker: SharedMemoryArray
    _check_state: np.uint8
    _reset_encoder: np.uint8
    _monitoring: bool
    def __init__(
        self, encoder_ppr: int, wheel_diameter: float, cm_per_unity_unit: float, polling_frequency: int
    ) -> None: ...
    def __del__(self) -> None: ...
    def initialize_local_assets(self) -> None: ...
    def initialize_remote_assets(self) -> None: ...
    def terminate_remote_assets(self) -> None: ...
    def process_received_data(self, message: ModuleData) -> None: ...
    def set_parameters(self, report_ccw: np.bool, report_cw: np.bool, delta_threshold: np.uint32) -> None: ...
    def set_monitoring_state(self, *, state: bool) -> None: ...
    @property
    def cm_per_pulse(self) -> np.float64: ...
    @property
    def absolute_position(self) -> np.float64: ...
    @property
    def traveled_distance(self) -> np.float64: ...
    def reset_distance_tracker(self) -> None: ...

class LickInterface(ModuleInterface):
    _lick_threshold: np.uint16
    _polling_frequency: Incomplete
    _lick_tracker: SharedMemoryArray
    _previous_readout_zero: bool
    _check_state: np.uint8
    _monitoring: bool
    def __init__(self, lick_threshold: int, polling_frequency: int) -> None: ...
    def __del__(self) -> None: ...
    def initialize_local_assets(self) -> None: ...
    def initialize_remote_assets(self) -> None: ...
    def terminate_remote_assets(self) -> None: ...
    def process_received_data(self, message: ModuleData) -> None: ...
    def set_parameters(
        self, signal_threshold: np.uint16, delta_threshold: np.uint16, average_pool_size: np.uint8
    ) -> None: ...
    def set_monitoring_state(self, *, state: bool) -> None: ...
    @property
    def lick_count(self) -> np.uint64: ...
    @property
    def lick_threshold(self) -> np.uint16: ...

class TorqueInterface(ModuleInterface):
    _polling_frequency: np.uint32
    _torque_per_adc_unit: np.float64
    _check_state: np.uint8
    _monitoring: bool
    def __init__(
        self, baseline_voltage: int, maximum_voltage: int, sensor_capacity: float, polling_frequency: int
    ) -> None: ...
    def initialize_remote_assets(self) -> None: ...
    def terminate_remote_assets(self) -> None: ...
    def process_received_data(self, _message: ModuleData | ModuleState) -> None: ...
    def set_parameters(
        self,
        report_ccw: np.bool,
        report_cw: np.bool,
        signal_threshold: np.uint16,
        delta_threshold: np.uint16,
        averaging_pool_size: np.uint8,
    ) -> None: ...
    def set_monitoring_state(self, *, state: bool) -> None: ...
    @property
    def torque_per_adc_unit(self) -> np.float64: ...

class TTLInterface(ModuleInterface):
    _polling_frequency: np.uint32
    _pulse_tracker: SharedMemoryArray
    _check_state: np.uint8
    _monitoring: bool
    def __init__(self, polling_frequency: int) -> None: ...
    def __del__(self) -> None: ...
    def initialize_local_assets(self) -> None: ...
    def initialize_remote_assets(self) -> None: ...
    def terminate_remote_assets(self) -> None: ...
    def process_received_data(self, message: ModuleData | ModuleState) -> None: ...
    def set_parameters(self, averaging_pool_size: np.uint8) -> None: ...
    def set_monitoring_state(self, *, state: bool) -> None: ...
    @property
    def pulse_count(self) -> np.uint64: ...
    def reset_pulse_count(self) -> None: ...

class BrakeInterface(ModuleInterface):
    _minimum_brake_strength: np.float64
    _maximum_brake_strength: np.float64
    _engage: np.uint8
    _disengage: np.uint8
    _pulse: np.uint8
    _enabled: bool
    _previous_pulse_duration: int
    def __init__(self, minimum_brake_strength: float, maximum_brake_strength: float) -> None: ...
    def initialize_remote_assets(self) -> None: ...
    def terminate_remote_assets(self) -> None: ...
    def process_received_data(self, _message: ModuleData | ModuleState) -> None: ...
    def set_state(self, *, state: bool) -> None: ...
    def send_pulse(self, duration_ms: int) -> None: ...
    @property
    def maximum_brake_strength(self) -> np.float64: ...
    @property
    def minimum_brake_strength(self) -> np.float64: ...

class ValveInterface(ModuleInterface):
    _calibration_count: Incomplete
    _scale_coefficient: np.float64
    _nonlinearity_exponent: np.float64
    _valve_tracker: SharedMemoryArray
    _reward: np.uint8
    _open: np.uint8
    _close: np.uint8
    _calibrate: np.uint8
    _tone: np.uint8
    _previous_module_state: bool
    _configured_valve_state: bool
    _previous_volume: float
    _previous_tone_duration: int
    _cycle_timer: PrecisionTimer | None
    def __init__(self, valve_calibration_data: tuple[tuple[int | float, int | float], ...]) -> None: ...
    def __del__(self) -> None: ...
    def initialize_local_assets(self) -> None: ...
    def initialize_remote_assets(self) -> None: ...
    def terminate_remote_assets(self) -> None: ...
    def process_received_data(self, message: ModuleData | ModuleState) -> None: ...
    def set_state(self, *, state: bool) -> None: ...
    def deliver_reward(self, volume: float = 5.0, tone_duration: int = 300) -> None: ...
    def simulate_reward(self, tone_duration: int = 300) -> None: ...
    def reference_valve(self) -> None: ...
    def calibrate_valve(self, pulse_duration: int) -> None: ...
    def get_duration_from_volume(self, target_volume: float) -> np.uint32: ...
    @property
    def scale_coefficient(self) -> np.float64: ...
    @property
    def nonlinearity_exponent(self) -> np.float64: ...
    @property
    def delivered_volume(self) -> np.float64: ...
    @property
    def calibrating(self) -> bool: ...

class ScreenInterface(ModuleInterface):
    _toggle: np.uint8
    _enabled: bool
    def __init__(self) -> None: ...
    def initialize_remote_assets(self) -> None: ...
    def terminate_remote_assets(self) -> None: ...
    def process_received_data(self, _message: ModuleData | ModuleState) -> None: ...
    def set_parameters(self, pulse_duration: np.uint32) -> None: ...
    def set_state(self, *, state: bool) -> None: ...
    @property
    def state(self) -> bool: ...

class GasPuffValveInterface(ModuleInterface):
    _pulse: np.uint8
    _open: np.uint8
    _close: np.uint8
    _configured_state: bool
    _previous_module_state: bool
    _previous_duration: int
    _puff_tracker: SharedMemoryArray
    def __init__(self) -> None: ...
    def initialize_remote_assets(self) -> None: ...
    def terminate_remote_assets(self) -> None: ...
    def initialize_local_assets(self) -> None: ...
    def process_received_data(self, message: ModuleData | ModuleState) -> None: ...
    def set_state(self, *, state: bool) -> None: ...
    def deliver_puff(self, duration_ms: int = 100) -> None: ...
    @property
    def puff_count(self) -> int: ...
