"""This module provides Visualizer classes to render hardware module data in real time."""

import numpy as np
import matplotlib

matplotlib.use("QtAgg")  # Uses QT backend for performance and compatibility with Linux

from matplotlib.ticker import MaxNLocator
import matplotlib.pyplot as plt
from ataraxis_base_utilities import console
from ataraxis_data_structures import SharedMemoryArray
from ataraxis_time import PrecisionTimer

# Updates plotting dictionaries to preferentially use Arial text style and specific sizes for different text elements
# in plots:
# General parameters and the font size for axes' tick numbers
plt.rcParams.update({"font.family": "Arial", "font.weight": "normal", "xtick.labelsize": 16, "ytick.labelsize": 16})
_fontdict_axis_label = {"family": "Arial", "weight": "normal", "size": 18}  # Axis label fonts
_fontdict_title = {"family": "Arial", "weight": "normal", "size": 20}  # Title fonts
_fontdict_legend = {"family": "Arial", "weight": "normal", "size": 16}  # Legend fonts

# Initializes dictionaries to map colloquial names to specific linestyle and color parameters
_line_style_dict = {"solid": "-", "dashed": "--", "dotdashed": "_.", "dotted": ":"}
_palette_dict = {
    "green": (0.000, 0.639, 0.408),
    "blue": (0.000, 0.525, 0.749),
    "red": (0.769, 0.008, 0.137),
    "yellow": (1.000, 0.827, 0.000),
    "purple": (0.549, 0.000, 0.749),
    "orange": (1.000, 0.502, 0.000),
    "pink": (0.945, 0.569, 0.608),
    "black": (0.000, 0.000, 0.000),
    "white": (1.000, 1.000, 1.000),
    "gray": (0.500, 0.500, 0.500),
}


def _plt_palette(color: str) -> tuple[float, float, float]:
    """Converts colloquial color names to pyplot RGB color codes.

    The provided colors are not perfectly colorblind-friendly. They should be used with different 'line style' formats
    to improve readability in monochrome spectrum. The codes generated by this function should be passed to 'color'
    argument of the pyplot module.

    Args:
        color: Colloquial name of the color to be retrieved. Available options are: 'green', 'blue', 'red', 'yellow',
            'purple', 'orange', 'pink', 'black', 'white', 'gray'.

    Returns:
        A list of R, G, and B values for the requested color.

    Raises:
        KeyError: If the provided color is not recognized.
    """

    try:
        return _palette_dict[color]
    except KeyError:
        message = (
            f"Unexpected color name '{color}' encountered when converting the colloquial color name to RGB array. "
            f"Provide one of the supported color arguments: {', '.join(_palette_dict.keys())}."
        )
        console.error(message=message, error=KeyError)
        # Fallback to appease mypy, should not be reachable
        raise KeyError(message)  # pragma: no cover


def _plt_line_styles(line_style: str) -> str:
    """Converts colloquial line style names to pyplot's 'lifestyle' string-codes.

    Args:
        line_style: Colloquial name for the line style to be used. Options are 'solid', 'dashed', 'dotdashed' and
            'dotted'.

    Returns:
        The string-code for the requested line style.

    Raises:
        KeyError: If the provided line style is not recognized.
    """

    try:
        return str(_line_style_dict[line_style])
    except KeyError:
        message = (
            f"Unexpected line style name '{line_style}' encountered when converting the colloquial line style pyplot "
            f"linestyle string. Provide one of the supported line style arguments: "
            f"{', '.join(_line_style_dict.keys())}."
        )
        console.error(message=message, error=KeyError)
        # Fallback to appease mypy, should not be reachable
        raise KeyError(message)  # pragma: no cover


class BehaviorVisualizer:
    """Visualizes lick, valve, and running speed data in real time.

    This class is used to visualize the key behavioral metrics collected from animals performing experiment or training
    sessions in the Mesoscope-VR system. Note, the class is statically configured to generate the plots for all
    supported metrics, even if some of them are not used during a particular session.

    Args:
        lick_tracker: The SharedMemoryArray instance exposed by the LickInterface class that communicates the number of
            licks recorded by the class since runtime onset.
        valve_tracker: The SharedMemoryArray instance exposed by the ValveInterface class that communicates the number
            of times the valve has been opened since runtime onset.
        distance_tracker: The SharedMemoryArray instance exposed by the EncoderInterface class that communicates the
            total distance traveled by the animal since runtime onset, in centimeters.

    Attributes:
        _time_window: Specifies the time window, in seconds, to visualize during runtime. Currently, this is statically
            set to 20 seconds.
        _time_step: Specifies the interval, in milliseconds, at which to update the visualization plots. Currently, this
            is statically set to 30 milliseconds, which gives a good balance between update smoothness and rendering
            time.
        _update_timer: The PrecisionTimer instance used to ensure that the figure is updated once every _time_step
            milliseconds.
        _lick_tracker: Stores the lick_tracker SharedMemoryArray.
        _valve_tracker: Stores the valve_tracker SharedMemoryArray.
        _distance_tracker: Stores the distance_tracker SharedMemoryArray.
        _timestamps: A numpy array that stores the timestamps of the displayed data during visualization runtime. The
            timestamps are generated at class initialization and are kept constant during runtime.
        _lick_data: A numpy array that stores the data used to generate the lick sensor state plot.
        _valve_data: A numpy array that stores the data used to generate the solenoid valve state plot.
        _speed_data: A numpy array that stores the data used to generate the running speed plot.
        _previous_valve_count: Stores the total number of valve pulses sampled during the previous update cycle.
        _previous_lick_count: Stores the total number of licks sampled during the previous update cycle.
        _previous_distance: Stores the total distance traveled by the animal sampled during the previous update cycle.
        _speed_timer: Stores the PrecisionTimer instance used to convert traveled distance into running speed.
        _lick_line: Stores the line class used to plot the lick sensor data.
        _valve_line: Stores the line class used to plot the solenoid valve data.
        _speed_line: Stores the line class used to plot the average running speed data.
        _figure: Stores the matplotlib figure instance used to display the plots.
        _initialized: Tracks whether the figure managed by the class has been initialized.
        _lick_axis: The axis object used to plot the lick sensor data during visualization runtime.
        _valve_axis: The axis object used to plot the solenoid valve data during visualization runtime.
        _speed_axis: The axis object used to plot the average running speed data during visualization runtime.
    """

    def __init__(
        self,
        lick_tracker: SharedMemoryArray,
        valve_tracker: SharedMemoryArray,
        distance_tracker: SharedMemoryArray,
    ) -> None:
        # Currently, the class is statically configured to visualize the sliding window of 20 seconds.
        self._time_window: int = 20
        self._time_step: int = 30
        self._update_timer = PrecisionTimer("ms")

        # Saves the input trackers to class attributes
        self._lick_tracker = lick_tracker
        self._valve_tracker = valve_tracker
        self._distance_tracker = distance_tracker

        # Precreates the structures used to store the displayed data during visualization runtime
        self._timestamps = np.arange(
            start=0 - self._time_window, stop=self._time_step / 1000, step=self._time_step / 1000, dtype=np.float32
        )
        self._lick_data = np.zeros_like(a=self._timestamps, dtype=np.uint8)
        self._valve_data = np.zeros_like(a=self._timestamps, dtype=np.uint8)
        self._speed_data = np.zeros_like(a=self._timestamps, dtype=np.float64)
        self._previous_valve_count = np.float64(0)
        self._previous_lick_count = np.uint64(0)
        self._previous_distance = np.float64(0)

        # Initializes additional assets used to generate the running speed data from the distance tracking data.
        self._speed_timer = PrecisionTimer("ms")

        # Line objects (to be created during initialization)
        self._lick_line = None
        self._valve_line = None
        self._speed_line = None

        # Figure objects
        self._initialized = False
        self._figure = None
        self._lick_axis = None
        self._valve_axis = None
        self._speed_axis = None

    def initialize(self) -> None:
        """Initializes the visualization runtime.

        This method generates and renders the plot figure. During runtime, most of the plot will be kept constant, which
        saves rendering time. In turn, this allows the visualizer to work with higher data sampling rates.
        """

        # Prevents this method from running for an already initialized class
        if self._initialized:
            return

        # Creates the figure with three subplots sharing the same x-axis
        self._figure, (self._lick_axis, self._valve_axis, self._speed_axis) = plt.subplots(
            3, 1, figsize=(10, 8), sharex=True, gridspec_kw={"hspace": 0.3, "left": 0.15}
        )

        # Sets consistent y-label padding for all axes. This aligns y-axis names for all axes, making the figure more
        # readable.
        self._lick_axis.yaxis.labelpad = 15
        self._valve_axis.yaxis.labelpad = 15
        self._speed_axis.yaxis.labelpad = 15

        # Set up axes properties. This is only done once, during class initialization, and the elements made by
        # this method stay unchanged throughout the entire class runtime.
        self._setup_axes()

        # Creates the plot artists. Plot artists are updated each time update() method is called to re-render the
        # line using new data.
        self._setup_plot_artists()

        # Generates the figure object and updates it to show the initial (zero-initialized) data state.
        plt.show(block=False)
        self._figure.canvas.draw()
        self._figure.canvas.flush_events()

        # Sets the initialization flag
        self._initialized = True

    def _setup_axes(self) -> None:
        """Configures all axes.

        This method is called during initialize() runtime to generate the properties for all plots. These properties
        are kept constant throughout the class runtime.
        """
        # Lick axis
        self._lick_axis.set_title("Lick Sensor State", fontdict=_fontdict_title)
        self._lick_axis.set_ylim(-0.05, 1.05)
        self._lick_axis.set_ylabel("Lick State", fontdict=_fontdict_axis_label)
        self._lick_axis.set_xlabel("")
        self._lick_axis.yaxis.set_major_locator(plt.FixedLocator([0, 1]))
        self._lick_axis.yaxis.set_major_formatter(plt.FixedFormatter(["No Lick", "Lick"]))

        # Valve axis
        self._valve_axis.set_title("Reward Valve State", fontdict=_fontdict_title)
        self._valve_axis.set_ylim(-0.05, 1.05)
        self._valve_axis.set_ylabel("Valve State", fontdict=_fontdict_axis_label)
        self._valve_axis.set_xlabel("")
        self._valve_axis.yaxis.set_major_locator(plt.FixedLocator([0, 1]))
        self._valve_axis.yaxis.set_major_formatter(plt.FixedFormatter(["Closed", "Open"]))

        # Speed axis
        self._speed_axis.set_title("Average Running Speed", fontdict=_fontdict_title)
        self._speed_axis.set_ylim(-2, 32)
        self._speed_axis.set_ylabel("Running speed (cm/s)", fontdict=_fontdict_axis_label)
        self._speed_axis.set_xlabel("Time (s)", fontdict=_fontdict_axis_label)
        self._speed_axis.yaxis.set_major_locator(MaxNLocator(nbins="auto", integer=False))
        self._speed_axis.xaxis.set_major_locator(MaxNLocator(nbins="auto", integer=True))

        # Sets x-limits for all axes (shared x-axis)
        self._speed_axis.set_xlim(-self._time_window, 0)

        # Hides x-tick labels for top plots
        plt.setp(self._lick_axis.get_xticklabels(), visible=False)
        plt.setp(self._valve_axis.get_xticklabels(), visible=False)

        # Aligns all y-labels
        self._figure.align_ylabels([self._lick_axis, self._valve_axis, self._speed_axis])

    def _setup_plot_artists(self) -> None:
        """Creates the artists (plot lines) for the data.

        The artists are used during update() method runtime to re-render the lines using updated data. This minimizes
        rendering to the elements that actually change during runtime, keeping other figure elements static.
        """

        # Lick plot
        (self._lick_line,) = self._lick_axis.plot(
            self._timestamps,
            self._lick_data,
            drawstyle="steps-post",
            color=_plt_palette("red"),
            linewidth=2,
            alpha=1.0,
            linestyle="solid",
        )

        # Valve plot
        (self._valve_line,) = self._valve_axis.plot(
            self._timestamps,
            self._valve_data,
            drawstyle="steps-post",
            color=_plt_palette("blue"),
            linewidth=2,
            alpha=1.0,
            linestyle="solid",
        )

        # Speed plot
        (self._speed_line,) = self._speed_axis.plot(
            self._timestamps, self._speed_data, color=_plt_palette("green"), linewidth=2, alpha=1.0, linestyle="solid"
        )

    def update(self) -> None:
        """Updates the figure managed by the class to display new data.

        This method discards the oldest datapoint in the plot memory and instead samples a new datapoint. It also shifts
        all datapoints one timestamp to the left. When the method is called repeatedly, this makes the plot lines
        naturally flow from the right (now) to the left (20 seconds in the past), accurately displaying the visualized
        data history.

        Notes:
            The method has an internal update frequency limiter. Therefore, to achieve optimal performance, call this
            method as frequently as possible and rely on the internal limiter to force the specific update frequency.
        """
        # If the class is not initialized, carries out initialization
        if not self._initialized:
            self.initialize()
            return

        # Ensures the plot is not updated any faster than necessary to resolve the time-step used by the plot
        if self._update_timer.elapsed < self._time_step:
            return
        self._update_timer.reset()

        # Replaces the oldest timestamp data with the current data.
        self._sample_data()

        # Updates the artists with new data
        self._lick_line.set_data(self._timestamps, self._lick_data)
        self._valve_line.set_data(self._timestamps, self._valve_data)
        self._speed_line.set_data(self._timestamps, self._speed_data)

        # Renders the changes
        self._figure.canvas.draw()
        self._figure.canvas.flush_events()

    def close(self) -> None:
        """Closes the visualized figure and cleans up the resources used by the class during runtime."""
        if self._initialized:
            plt.close(self._figure)  # Closes the figure

            # Resets internal object references
            self._figure = None
            self._lick_axis = None
            self._valve_axis = None
            self._speed_axis = None
            self._initialized = False

    def _sample_data(self) -> None:
        """Samples new data from tracker SharedMemoryArray instances and update the class memory."""
        # Rolls arrays by one position to the left, so the first element becomes last
        self._valve_data = np.roll(self._valve_data, shift=-1)
        self._lick_data = np.roll(self._lick_data, shift=-1)
        self._speed_data = np.roll(self._speed_data, shift=-1)

        # Replaces the last element (previously the first or 'oldest' value) with new data:

        # Each time the overall lick count increments, displays a lick trigger. Lick counts are incremented at each
        # rising edge of lick detection.
        new_count = self._lick_tracker.read_data(index=0, convert_output=False)
        if new_count != self._previous_lick_count:
            self._lick_data[-1] = np.uint8(1)
        else:
            self._lick_data[-1] = np.uint8(0)
        self._previous_lick_count = new_count

        # Carries out a similar computation for valve tracker. Valve pulse counter also increments on the rising edge
        # of each valve open-close cycle.
        new_valve_count = self._valve_tracker.read_data(index=0, convert_output=False)
        if new_valve_count != self._previous_valve_count:
            self._valve_data[-1] = np.uint8(1)
        else:
            self._valve_data[-1] = np.uint8(0)
        self._previous_valve_count = new_valve_count

        # Finally, speed is computed slightly differently. This is because the update rate of this class exceeds the
        # smoothing window size used to generate running speed:

        # The speed is actually updated ~every 100 milliseconds. Until the update timeout is exhausted, at each update
        # cycle the last speed point is overwritten with the previous update point. This would generate a sequence of
        # 3-4 identical speed readouts, but this should not be very noticeable to the user.
        if self._speed_timer.elapsed < 100:
            self._speed_data[-1] = self._speed_data[-2]
        else:
            # Once the timeout passes, determines the total distance covered by the animal while the timeout was
            # active and uses it to compute the running speed in cm/s
            self._speed_timer.reset()
            travelled_distance: np.float64 = self._distance_tracker.read_data(index=0, convert_output=False)
            delta_distance = travelled_distance - self._previous_distance
            running_speed = np.float64((delta_distance / 100) * 1000)  # Gets distance in cm / ms and converts to cm / s

            # Inserts the newly computed datapoint into the data array and updates the previous distance tracker
            self._speed_data[-1] = running_speed
            self._previous_distance = travelled_distance
