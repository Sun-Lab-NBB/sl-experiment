"""This module provides Visualizer classes used to render the data from some hardware modules in real time."""

import threading
from typing import Any, Optional
import numpy as np

# Forces matplotlib to use a linux-compatible backend
import matplotlib

matplotlib.use("Tkagg")

from matplotlib.ticker import MaxNLocator
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from matplotlib.figure import Figure
from matplotlib.axes import Axes
from ataraxis_base_utilities import console
from ataraxis_time import PrecisionTimer
from ataraxis_data_structures import SharedMemoryArray

# Updates plotting dictionaries to preferentially use bolded Arial text style and specific sizes for different
# text elements in plots:
# General parameters and the font size for axes' tick numbers
plt.rcParams.update({"font.family": "Arial", "font.weight": "normal", "xtick.labelsize": 18, "ytick.labelsize": 18})

# Axis label fonts
_fontdict_axis_label = {"family": "Arial", "weight": "normal", "size": 22}

# Title fonts
_fontdict_title = {"family": "Arial", "weight": "normal", "size": 24}

# Legend fonts
_fontdict_legend = {"family": "Arial", "weight": "normal", "size": 18}

# This dictionary contains supported line styles. It is accessed through the plt_line_style function.
_line_style_dict = {"solid": "-", "dashed": "--", "dotdashed": "_.", "dotted": ":"}

# This dictionary maps colloquial color names to specific RGB values.
_palette_dict = {
    "green": (0.000, 0.639, 0.408),
    "blue": (0.000, 0.525, 0.749),
    "red": (0.769, 0.008, 0.137),
    "yellow": (1.000, 0.827, 0.000),
    "purple": (0.549, 0.000, 0.749),
    "orange": (1.000, 0.502, 0.000),
    "pink": (0.945, 0.569, 0.608),
    "black": (0.000, 0.000, 0.000),
    "white": (1.000, 1.000, 1.000),
    "gray": (0.500, 0.500, 0.500),
}


def _plt_palette(color: str) -> tuple[float, float, float]:
    """Converts colloquial color names to pyplot RGB color codes.

    The provided colors are not perfectly colorblind-friendly. They should be used with different 'line style formats
    to improve readability in monochrome spectrum. The codes generated by this function should be passed to 'color'
    argument of the pyplot module.

    Args:
        color: Colloquial name of the color to be retrieved. Available options are: 'green', 'blue', 'red', 'yellow',
            'purple', 'orange', 'pink', 'black', 'white', 'gray'.

    Returns:
        A list of R, G, and B values for the requested color.

    Raises:
        KeyError: If the provided color is not recognized.
    """

    try:
        return _palette_dict[color]
    except KeyError:
        message = (
            f"Unexpected color name '{color}' encountered when converting the colloquial color name to RGB array. "
            f"Provide one of the supported color arguments: {', '.join(_palette_dict.keys())}."
        )
        console.error(message=message, error=KeyError)
        # Fallback to appease mypy, should not be reachable
        raise KeyError(message)  # pragma: no cover


def _plt_line_styles(line_style: str) -> str:
    """Converts colloquial line style names to pyplot's 'lifestyle' string-codes.

    Args:
        line_style: Colloquial name for the line style to be used. Options are 'solid', 'dashed', 'dotdashed' and
            'dotted'.

    Returns:
        The string-code for the requested line style.

    Raises:
        KeyError: If the provided line style is not recognized.
    """

    try:
        return str(_line_style_dict[line_style])
    except KeyError:
        message = (
            f"Unexpected line style name '{line_style}' encountered when converting the colloquial line style pyplot "
            f"linestyle string. Provide one of the supported line style arguments: "
            f"{', '.join(_line_style_dict.keys())}."
        )
        console.error(message=message, error=KeyError)
        # Fallback to appease mypy, should not be reachable
        raise KeyError(message)  # pragma: no cover


class BehaviorVisualizer:
    """Visualizes behavioral data in real-time during experiment or training runtimes.

    Primarily, this class is used to visualize licks, reward delivery, and running speed data while animals perform
    experiment or training sessions in the Mesoscope-VR system.

    Args:
        lick_training: Determines whether the visualizer is used for lick training. Since lick training does not
            involve any running, this runtime format does not visualize running speed.
        time_window: The time window, in seconds, for which to plot the data.
        update_interval: The interval, in milliseconds, between visualization updates.
    """

    def __init__(
        self,
        lick_training: bool,
        lick_tracker: SharedMemoryArray,
        valve_tracker: SharedMemoryArray,
        speed_tracker: SharedMemoryArray,
        time_window: int = 60,
        update_interval: int = 10,
        lick_threshold: int = 1000,
    ) -> None:
        # Generates the timer used to timestamp the incoming data. This is used to enforce the visualization window.
        self._timer = PrecisionTimer("ms")

        # Saves runtime configuration data to class attributes
        self._lick_training = lick_training
        self._minimum_time = -time_window * 1000  # Converts to milliseconds and flips to negative
        self._update_interval = update_interval
        self._lick_threshold = lick_threshold

        # Precreates storage structures used to store the displayed data during visualization runtime
        self._timestamps = np.arange(start=0, stop=time_window * 1000, step=update_interval, dtype=np.uint32)
        self._lick_data = np.zeros_like(a=self._timestamps, dtype=np.uint16)
        self._valve_data = np.zeros_like(a=self._timestamps, dtype=np.uint8)
        self._speed_data = np.zeros_like(a=self._timestamps, dtype=np.float64)
        self._total_volume: np.float64 = np.float64(0)

        # Extracts tracker arrays from input interfaces. This is sued to directly sample the data from these arrays
        # during runtime.
        self._lick_tracker = lick_tracker
        self._valve_tracker = valve_tracker
        self._speed_tracker = speed_tracker

        # Precreates plot objects used for visualization
        self._fig: Optional[Figure] = None
        self._lick_axis: Optional[Axes] = None
        self._valve_axis: Optional[Axes] = None
        self._ani: Optional[animation.FuncAnimation] = None

        # Sets up the thread used to continuously update the visualized plot
        self._vis_thread: Optional[threading.Thread] = None
        self._running = False

    def start(self) -> None:
        """Starts the visualization thread."""
        if self._running:
            return

        self._running = True
        self._vis_thread = threading.Thread(target=self._run_visualization, daemon=True)
        self._vis_thread.start()

    def stop(self) -> None:
        """Stops the visualization thread and releases all resources reserved by matplotlib."""
        self._running = False
        if self._vis_thread:
            self._vis_thread.join(timeout=1.0)
            self._vis_thread = None

    def _run_visualization(self) -> None:
        """Initializes the matplotlib visualization and displays the figure window."""
        # Creates the figure and subplots
        self._fig, (self._lick_axis, self._valve_axis) = plt.subplots(2, 1, figsize=(10, 8))

        # Creates animation - update_plot will be called at the specified interval in milliseconds
        # noinspection PyTypeChecker
        self._ani = animation.FuncAnimation(
            self._fig,
            self._update_plot,
            interval=self._update_interval,
            blit=False,
            cache_frame_data=False,
        )

        # Enables interactive mode to prevent plt.show() from blocking
        plt.ion()

        # Shows the figure without blocking
        self._fig.show()

        # Blocks in-place until the class initializes the shutdown sequence.
        while self._running:
            # Updates the figure canvas to keep up with the changes
            self._fig.canvas.draw_idle()
            self._fig.canvas.flush_events()
            self._timer.delay_noblock(delay=self._update_interval)

        # Cleans up after the loop above exits
        self._cleanup_resources()

    def _cleanup_resources(self):
        """Cleans up matplotlib resources."""
        # Stops the animation
        if self._ani is not None:
            self._ani.event_source.stop()
            self._ani = None

        # Closes the figure
        if self._fig is not None:
            plt.close(self._fig)
            self._fig = None

        # Clears axis references
        self._lick_axis = None
        self._valve_axis = None

    def _update_plot(self, frame: Any) -> None:
        """Update the visualized plot with new data.

        Args:
            frame: Frame number (automatically provided by FuncAnimation).
        """
        # Replaces the oldest datapoint with a new data sample taken from the data trackers.
        self._sample_data()

        # Clears previous plots
        self._lick_axis.cla()
        self._valve_axis.cla()

        # Updates the plots to use new data
        self._update_lick_plot()
        self._update_valve_plot()

        # Forces tight layout
        plt.tight_layout()

    def _update_lick_plot(self) -> None:
        """Updates the lick sensor plot with new data."""
        # Plots lick ADC units as discrete steps
        if self._timestamps:
            self._lick_axis.plot(
                self._timestamps,
                self._lick_data,
                drawstyle="steps-post",
                alpha=1.0,
                linewidth=2,
                color=_plt_palette("red"),
                linestyle="solid",
            )

        # Plots the lick detection threshold line
        self._lick_axis.axhline(
            y=self._lick_threshold,
            color=_plt_palette("black"),
            linestyle="dashed",
            linewidth=1.5,
            alpha=0.7,
            label="Lick Threshold",
        )

        # Adds a legend to identify the threshold line
        self._lick_axis.legend(fontdict=_fontdict_legend, loc="upper right")

        # Configures plot layout
        self._lick_axis.set_title("Lick Sensor State", fontdict=_fontdict_title)
        self._lick_axis.set_xlim(self._minimum_time, 0)  # Right edge is now, left edge is milliseconds in the past
        self._lick_axis.set_ylim(0, 4096, fontdict=_fontdict_axis_label)
        self._lick_axis.set_ylabel("Voltage / ADC units", fontdict=_fontdict_axis_label)
        self._lick_axis.set_xlabel("Time (ms)", fontdict=_fontdict_axis_label)

        # Optimizes tick locations and forces integer data to use integer ticks where possible
        self._lick_axis.xaxis.set_major_locator(MaxNLocator(nbins="auto", integer=True))
        self._lick_axis.yaxis.set_major_locator(MaxNLocator(nbins="auto", integer=True))

    def _update_valve_plot(self) -> None:
        """Updates the reward valve plot with new data."""

        # Plots valve state as discrete steps (0 or 1)
        if self._timestamps:
            self._valve_axis.plot(
                self._timestamps,
                self._valve_data,
                drawstyle="steps-post",
                alpha=1.0,
                linewidth=2,
                color=_plt_palette("blue"),
                linestyle="solid",
            )

        # Configures plot layout
        self._valve_axis.set_title("Reward Valve State", fontdict=_fontdict_title)
        self._valve_axis.set_xlim(self._minimum_time, 0)  # Right edge is now, left edge is milliseconds in the past
        self._valve_axis.set_ylim(0, 1)
        self._valve_axis.set_ylabel("Valve State (0: closed, 1: open)", fontdict=_fontdict_axis_label)
        self._lick_axis.set_xlabel("Time (ms)", fontdict=_fontdict_axis_label)

        # Add text showing total water volume if available
        self._valve_axis.text(
            0.05,
            0.9,  # Position in axis coordinates (5% from the left, 90% from bottom)
            f"Total Volume: {self._total_volume:.2f} μL",
            transform=self._valve_axis.transAxes,
            fontdict=_fontdict_legend,
            bbox=dict(facecolor="white", alpha=0.7),
        )

        # Optimizes tick locations - forces y-ticks to be at 0 and 1 only
        self._valve_axis.xaxis.set_major_locator(MaxNLocator(nbins="auto", integer=True))
        self._valve_axis.yaxis.set_major_locator(plt.FixedLocator([0, 1]))
        self._valve_axis.yaxis.set_major_formatter(plt.FixedFormatter(["Closed", "Open"]))

    # def _update_movement_plot(self, ax: Axes, t_min: float, t_max: float) -> None:
    #     """Update the movement plot.
    #
    #     Args:
    #         ax: The matplotlib axis to plot on
    #         t_min: Minimum time to display
    #         t_max: Maximum time to display
    #     """
    #     times_delta = [d[0] for d in self._data_delta]
    #     deltas = [d[1] for d in self._data_delta]
    #
    #     if times_delta:
    #         # Compute cumulative sum of deltas, then shift so it starts at 0
    #         cumulative_delta = np.cumsum(deltas)
    #         if len(cumulative_delta) > 0:
    #             cumulative_delta = cumulative_delta - cumulative_delta[0]
    #             ax.plot(times_delta, cumulative_delta, color="green")
    #
    #     # Calculate average speed (cm/s) over the window
    #     total_delta = sum(deltas) if deltas else 0
    #     avg_speed = total_delta / self._time_window if self._time_window > 0 else 0
    #
    #     # Set title and labels
    #     ax.set_title(f"Average running speed / cm/s")
    #     ax.set_xlim(t_min, t_max)
    #     ax.set_ylabel("Running speed / cm/s", fontdict=_fontdict_axis_label)
    #     self._lick_axis.set_xlabel("Time (ms)", fontdict=_fontdict_axis_label)
    #
    #     # Displays average speed as text
    #     ax.text(
    #         0.05,
    #         0.9,
    #         f"Avg Speed: {avg_speed:.2f} cm/s",
    #         transform=ax.transAxes,
    #         fontdict=_fontdict_legend,
    #         bbox=dict(facecolor="white", alpha=0.7),
    #     )

    def _sample_data(self) -> None:
        """Samples the data currently stored inside the tracker SharedMemoryArray instances of the visualized modules
        and saves it in the visualizer memory.

        This method is continuously called during _update_plot() runtime to replace the oldest datapoint in memory with
        new data. The method shifts the data in memory so that it is properly aligned with correct timestamps, depending
        on the 'age' of the data.
        """
        # Rolls arrays by one position to the left, so that the first element becomes last
        self._valve_data = np.roll(self._valve_data, shift=1)
        self._lick_data = np.roll(self._lick_data, shift=1)
        self._speed_data = np.roll(self._speed_data, shift=1)

        # Replaces the last element (which was previously the first) with new data
        self._valve_data[-1] = self._valve_tracker.read_data(index=0, convert_output=False)
        self._lick_data[-1] = self._lick_tracker.read_data(index=0, convert_output=False)
        self._speed_data[-1] = self._speed_tracker.read_data(index=0, convert_output=False)

        # Also updates the total volume dispensed by the valve
        self._total_volume = self._valve_tracker.read_data(index=1, convert_output=False)
