"""This module provides Visualizer classes to render hardware module data in real time."""

import numpy as np
import matplotlib

matplotlib.use("QtAgg")  # Uses QT backend for performance and compatibility with Linux

from matplotlib.ticker import MaxNLocator
import matplotlib.pyplot as plt
from ataraxis_base_utilities import console, LogLevel
from ataraxis_data_structures import SharedMemoryArray

# Updates plotting dictionaries to preferentially use Arial text style and specific sizes for different text elements
# in plots:
# General parameters and the font size for axes' tick numbers
plt.rcParams.update({"font.family": "Arial", "font.weight": "normal", "xtick.labelsize": 16, "ytick.labelsize": 16})
_fontdict_axis_label = {"family": "Arial", "weight": "normal", "size": 18}  # Axis label fonts
_fontdict_title = {"family": "Arial", "weight": "normal", "size": 20}  # Title fonts
_fontdict_legend = {"family": "Arial", "weight": "normal", "size": 16}  # Legend fonts

# Initializes dictionaries to map colloquial names to specific linestyle and color parameters
_line_style_dict = {"solid": "-", "dashed": "--", "dotdashed": "_.", "dotted": ":"}
_palette_dict = {
    "green": (0.000, 0.639, 0.408),
    "blue": (0.000, 0.525, 0.749),
    "red": (0.769, 0.008, 0.137),
    "yellow": (1.000, 0.827, 0.000),
    "purple": (0.549, 0.000, 0.749),
    "orange": (1.000, 0.502, 0.000),
    "pink": (0.945, 0.569, 0.608),
    "black": (0.000, 0.000, 0.000),
    "white": (1.000, 1.000, 1.000),
    "gray": (0.500, 0.500, 0.500),
}


def _plt_palette(color: str) -> tuple[float, float, float]:
    """Converts colloquial color names to pyplot RGB color codes.

    The provided colors are not perfectly colorblind-friendly. They should be used with different 'line style' formats
    to improve readability in monochrome spectrum. The codes generated by this function should be passed to 'color'
    argument of the pyplot module.

    Args:
        color: Colloquial name of the color to be retrieved. Available options are: 'green', 'blue', 'red', 'yellow',
            'purple', 'orange', 'pink', 'black', 'white', 'gray'.

    Returns:
        A list of R, G, and B values for the requested color.

    Raises:
        KeyError: If the provided color is not recognized.
    """

    try:
        return _palette_dict[color]
    except KeyError:
        message = (
            f"Unexpected color name '{color}' encountered when converting the colloquial color name to RGB array. "
            f"Provide one of the supported color arguments: {', '.join(_palette_dict.keys())}."
        )
        console.error(message=message, error=KeyError)
        # Fallback to appease mypy, should not be reachable
        raise KeyError(message)  # pragma: no cover


def _plt_line_styles(line_style: str) -> str:
    """Converts colloquial line style names to pyplot's 'lifestyle' string-codes.

    Args:
        line_style: Colloquial name for the line style to be used. Options are 'solid', 'dashed', 'dotdashed' and
            'dotted'.

    Returns:
        The string-code for the requested line style.

    Raises:
        KeyError: If the provided line style is not recognized.
    """

    try:
        return str(_line_style_dict[line_style])
    except KeyError:
        message = (
            f"Unexpected line style name '{line_style}' encountered when converting the colloquial line style pyplot "
            f"linestyle string. Provide one of the supported line style arguments: "
            f"{', '.join(_line_style_dict.keys())}."
        )
        console.error(message=message, error=KeyError)
        # Fallback to appease mypy, should not be reachable
        raise KeyError(message)  # pragma: no cover


class BehaviorVisualizer:
    """Visualizes lick, valve, and running speed data in real time.

    This class is used to visualize the key behavioral metrics collected from animals performing experiment or training
    sessions in the Mesoscope-VR system. Note, the class is statically configured to generate the plots for all
    supported metrics, even if some of them are not used during a particular session.

    Args:
        lick_tracker: The SharedMemoryArray instance exposed by the LickInterface class that communicates the lick
            sensor status in real time.
        valve_tracker: The SharedMemoryArray instance exposed by the ValveInterface class that communicates the solenoid
            valve state in real time.
        speed_tracker: The SharedMemoryArray instance exposed by the EncoderInterface class that communicates the
            running speed of the animal calculated over 100 ms window.

    Attributes:
        _time_window: Specifies the time window, in seconds, to visualize during runtime. Currently, this is statically
            set to 20 seconds.
        _lick_tracker: Stores the lick_tracker SharedMemoryArray.
        _valve_tracker: Stores the valve_tracker SharedMemoryArray.
        _speed_tracker: Stores the speed_tracker SharedMemoryArray.
        _timestamps: A numpy array that stores the timestamps of the displayed data during visualization runtime. The
            timestamps are generated at class initialization and are kept constant during runtime.
        _lick_data: A numpy array that stores the data used to generate the lick sensor state plot.
        _valve_data: A numpy array that stores the data used to generate the solenoid valve state plot.
        _speed_data: A numpy array that stores the data used to generate the running speed plot.
        _previous_lick_state: Stores the lick state sampled during the previous update cycle.
        _previous_valve_state: Stores the valve state sampled during the previous update cycle.
        _lick_line: Stores the line class used to plot the lick sensor data.
        _valve_line: Stores the line class used to plot the solenoid valve data.
        _speed_line: Stores the line class used to plot the average running speed data.
        _figure: Stores the matplotlib figure instance used to display the plots.
        _initialized: Tracks whether the figure managed by the class has been initialized.
        _lick_axis: The axis object used to plot the lick sensor data during visualization runtime.
        _valve_axis: The axis object used to plot the solenoid valve data during visualization runtime.
        _speed_axis: The axis object used to plot the average running speed data during visualization runtime.
    """

    def __init__(
        self,
        lick_tracker: SharedMemoryArray,
        valve_tracker: SharedMemoryArray,
        speed_tracker: SharedMemoryArray,
    ) -> None:
        # Currently, the class is statically configured to visualize the sliding window of 20 seconds.
        self._time_window: int = 20

        # Saves the input trackers to class attributes
        self._lick_tracker = lick_tracker
        self._valve_tracker = valve_tracker
        self._speed_tracker = speed_tracker

        # Precreates the structures used to store the displayed data during visualization runtime
        self._timestamps = np.arange(start=0 - self._time_window, stop=0.025, step=0.025, dtype=np.float32)
        self._lick_data = np.zeros_like(a=self._timestamps, dtype=np.uint8)
        self._valve_data = np.zeros_like(a=self._timestamps, dtype=np.uint8)
        self._speed_data = np.zeros_like(a=self._timestamps, dtype=np.float32)
        self._previous_lick_state = np.uint8(0)
        self._previous_valve_state = np.uint8(0)

        # Line objects (to be created during initialization)
        self._lick_line = None
        self._valve_line = None
        self._speed_line = None

        # Figure objects
        self._initialized = False
        self._figure = None
        self._lick_axis = None
        self._valve_axis = None
        self._speed_axis = None

    def initialize(self) -> None:
        """Initializes the visualization runtime.

        This method generates and renders the plot figure. During runtime, most of the plot will be kept constant, which
        saves rendering time. In turn, this allows the visualizer to work with higher data sampling rates.
        """

        # Prevents this method from running for an already initialized class
        if self._initialized:
            return

        # Creates the figure with three subplots sharing the same x-axis
        self._figure, (self._lick_axis, self._valve_axis, self._speed_axis) = plt.subplots(
            3, 1, figsize=(10, 8), dpi=10, sharex=True, gridspec_kw={"hspace": 0.3, "left": 0.15}
        )

        # Sets consistent y-label padding for all axes. This aligns y-axis names for all axes, making the figure more
        # readable.
        self._lick_axis.yaxis.labelpad = 15
        self._valve_axis.yaxis.labelpad = 15
        self._speed_axis.yaxis.labelpad = 15

        # Set up axes properties. This is only done once, during class initialization, and the elements made by
        # this method stay unchanged throughout the entire class runtime.
        self._setup_axes()

        # Creates the plot artists. Plot artists are updated each time update() method is called to re-render the
        # line using new data.
        self._setup_plot_artists()

        # Generates the figure object and updates it to show the initial (zero-initialized) data state.
        plt.show(block=False)
        self._figure.canvas.draw()
        self._figure.canvas.flush_events()

        # Sets the initialization flag
        self._initialized = True

    def _setup_axes(self) -> None:
        """Configures all axes.

        This method is called during initialize() runtime to generate the properties for all plots. These properties
        are kept constant throughout the class runtime.
        """
        # Lick axis
        self._lick_axis.set_title("Lick Sensor State", fontdict=_fontdict_title)
        self._lick_axis.set_ylim(-0.05, 1.05)
        self._lick_axis.set_ylabel("Lick State", fontdict=_fontdict_axis_label)
        self._lick_axis.set_xlabel("")
        self._lick_axis.yaxis.set_major_locator(plt.FixedLocator([0, 1]))
        self._lick_axis.yaxis.set_major_formatter(plt.FixedFormatter(["No Lick", "Lick"]))

        # Valve axis
        self._valve_axis.set_title("Reward Valve State", fontdict=_fontdict_title)
        self._valve_axis.set_ylim(-0.05, 1.05)
        self._valve_axis.set_ylabel("Valve State", fontdict=_fontdict_axis_label)
        self._valve_axis.set_xlabel("")
        self._valve_axis.yaxis.set_major_locator(plt.FixedLocator([0, 1]))
        self._valve_axis.yaxis.set_major_formatter(plt.FixedFormatter(["Closed", "Open"]))

        # Speed axis
        self._speed_axis.set_title("Average Running Speed", fontdict=_fontdict_title)
        self._speed_axis.set_ylim(-2, 32)
        self._speed_axis.set_ylabel("Running speed (cm/s)", fontdict=_fontdict_axis_label)
        self._speed_axis.set_xlabel("Time (s)", fontdict=_fontdict_axis_label)
        self._speed_axis.yaxis.set_major_locator(MaxNLocator(nbins="auto", integer=False))
        self._speed_axis.xaxis.set_major_locator(MaxNLocator(nbins="auto", integer=True))

        # Sets x-limits for all axes (shared x-axis)
        self._speed_axis.set_xlim(-self._time_window, 0)

        # Hides x-tick labels for top plots
        plt.setp(self._lick_axis.get_xticklabels(), visible=False)
        plt.setp(self._valve_axis.get_xticklabels(), visible=False)

        # Aligns all y-labels
        self._figure.align_ylabels([self._lick_axis, self._valve_axis, self._speed_axis])

    def _setup_plot_artists(self) -> None:
        """Creates the artists (plot lines) for the data.

        The artists are used during update() method runtime to re-render the lines using updated data. This minimizes
        rendering to the elements that actually change during runtime, keeping other figure elements static.
        """

        # Lick plot
        (self._lick_line,) = self._lick_axis.plot(
            self._timestamps,
            self._lick_data,
            drawstyle="steps-post",
            color=_plt_palette("red"),
            linewidth=2,
            alpha=1.0,
            linestyle="solid",
        )

        # Valve plot
        (self._valve_line,) = self._valve_axis.plot(
            self._timestamps,
            self._valve_data,
            drawstyle="steps-post",
            color=_plt_palette("blue"),
            linewidth=2,
            alpha=1.0,
            linestyle="solid",
        )

        # Speed plot
        (self._speed_line,) = self._speed_axis.plot(
            self._timestamps, self._speed_data, color=_plt_palette("green"), linewidth=2, alpha=1.0, linestyle="solid"
        )

    def update(self) -> None:
        """Updates the figure managed by the class to display new data.

        This method discards the oldest datapoint in the plot memory and instead samples a new datapoint. It also shifts
        all datapoints one timestamp to the left. When the method is called repeatedly, this makes the plot lines
        naturally flow from the right (now) to the left (20 seconds in the past), accurately displaying the visualized
        data history.

        Notes:
            The method does not have any time limiters and will update the figure each time it is called. For the most
            accurate visualization, it is recommended to externally limit the calls to this method to ~ 10 Hz rate.
        """
        # If the class is not initialized, carries out initialization
        if not self._initialized:
            self.initialize()
            return

        # Replaces the oldest timestamp data with the current data.
        self._sample_data()

        # Updates the artists with new data
        self._lick_line.set_data(self._timestamps, self._lick_data)
        self._valve_line.set_data(self._timestamps, self._valve_data)
        self._speed_line.set_data(self._timestamps, self._speed_data)

        # Renders the changes
        self._figure.canvas.draw_idle()
        self._figure.canvas.flush_events()

    def close(self) -> None:
        """Closes teh visualized figure and cleans up the resources used by the class during runtime."""
        if self._initialized:
            plt.close(self._figure)  # Closes the figure

            # Resets internal object references
            self._figure = None
            self._lick_axis = None
            self._valve_axis = None
            self._speed_axis = None
            self._initialized = False

    def _sample_data(self) -> None:
        """Samples new data from tracker SharedMemoryArray instances and update the class memory."""
        # Rolls arrays by one position to the left, so the first element becomes last
        self._valve_data = np.roll(self._valve_data, shift=-1)
        self._lick_data = np.roll(self._lick_data, shift=-1)
        self._speed_data = np.roll(self._speed_data, shift=-1)

        # Replaces the last element (previously the first or 'oldest' value) with new data:

        # Lick and valve states are communicated as squares (rising and falling edges). However, we want to display
        # them as rising edge marks only. To do so, we manually track rising edges and only set the specific timestamp
        # that detects the rising edge to 1.
        new_lick = np.uint8(self._valve_tracker.read_data(index=0, convert_output=False))
        new_valve = np.uint8(self._lick_tracker.read_data(index=0, convert_output=False))

        # Only sets valve and lick data to 1 if the state communicates a rising edge change (from 0 to 1).
        # Otherwise, if the change is not a rising edge, keeps the data state at 0 for lick and valve states
        if not self._previous_lick_state and new_lick:
            self._valve_data[-1] = new_lick
        else:
            self._valve_data[-1] = np.uint8(0)
        if not self._previous_valve_state and new_valve:
            self._lick_data[-1] = new_valve
        else:
            self._lick_data[-1] = np.uint8(0)

        # Updates the tracker states with new data
        self._previous_lick_state = new_lick
        self._previous_valve_state = new_valve

        # Speed is reported continuously, so we do not need to do any special processing here.
        self._speed_data[-1] = self._speed_tracker.read_data(index=0, convert_output=False)


# Example usage
if __name__ == "__main__":
    console.enable()

    console.echo("Starting BehaviorVisualizer simulation...")

    # Create shared memory arrays for testing
    lick = SharedMemoryArray.create_array(
        name="fake_lick_data", prototype=np.zeros(shape=2, dtype=np.uint16), exist_ok=True
    )
    valve = SharedMemoryArray.create_array(
        name="fake_valve_data", prototype=np.zeros(shape=2, dtype=np.float64), exist_ok=True
    )
    speed = SharedMemoryArray.create_array(
        name="fake_speed_data", prototype=np.zeros(shape=1, dtype=np.float64), exist_ok=True
    )

    # Create and initialize the visualizer
    visualizer = BehaviorVisualizer(lick_tracker=lick, valve_tracker=valve, speed_tracker=speed)
    visualizer.initialize()

    # Generate test data
    samples = 2000

    # Generate random data with some patterns
    time_points = np.linspace(0, 20 * np.pi, samples)
    licks = (np.sin(time_points / 2) > 0.7).astype(int)  # Occasional high spikes
    valves = (np.sin(time_points / 5) > 0.8).astype(int)  # Occasional valve openings
    speeds = 10 + 5 * np.sin(time_points / 10) + np.random.normal(0, 1, samples)  # Sinusoidal movement with noise

    # Calculate cumulative volumes when valve is open
    volumes = np.zeros_like(valves, dtype=float)
    volume_per_activation = 2.5
    for i in range(len(valves)):
        if valves[i] == 1:
            volumes[i] = volume_per_activation
        if i > 0:
            volumes[i] += volumes[i - 1]

    # Main simulation loop - this would be your experiment/application loop
    index = 0
    while True:
        # Updates visualization (non-blocking)
        visualizer.update()

        lick.write_data(index=0, data=licks[index])
        valve.write_data(index=0, data=valves[index])
        valve.write_data(index=1, data=volumes[index])
        speed.write_data(index=0, data=speeds[index])
        index += 1

        # Print progress occasionally
        if index % 200 == 0:
            console.echo(f"Processed {index} samples", LogLevel.SUCCESS)

        if index == samples:
            break

    print("Simulation complete")

    visualizer.close()

    lick.disconnect()
    lick.destroy()
    valve.disconnect()
    valve.destroy()
    speed.disconnect()
    speed.destroy()
