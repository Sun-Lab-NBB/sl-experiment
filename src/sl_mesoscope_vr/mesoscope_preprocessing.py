"""This module provides the methods used to preprocess mesoscope data after acquisition. The primary purpose of this
preprocessing is to prepare the data for storage and further processing in the Sun lab data cluster."""

import tifffile
from pathlib import Path
from ataraxis_base_utilities import console, ensure_directory_exists
import numpy as np
from concurrent.futures import ProcessPoolExecutor, as_completed
from typing import Any
from functools import partial
from tqdm import tqdm


def _check_stack_size(file: Path) -> int:
    """Reads the header of the input TIFF file, and if the file is a stack, extracts its size.

    This function is used to both determine the stack size of the processed TIFF files and to exclude non-mesoscope
    TIFFs from processing.

    Notes:
        This function only works with monochrome TIFF stacks generated by the mesoscope. It expects each TIFF file to
        be a stack of 2D frames.

    Args:
        file: The path to the TIFF file to evaluate.

    Returns:
        If the file is a stack, returns the number of frames (pages) in the stack. Otherwise, returns 0 to indicate that
        the file is not a stack.
    """
    with tifffile.TiffFile(str(file)) as tif:
        # Gets number of pages (frames) from tiff header
        n_frames = len(tif.pages)

        # Considers all files with more than one page and a 2-dimensional (monochrome) image as a stack. For these
        # stacks, returns the discovered stack size (number of frames).
        if n_frames > 1 and len(tif.pages[0].shape) == 2:
            return n_frames
        # Otherwise, returns 0 to indicate that the file is not a stack.
        return 0


def _process_stack(tiff_path: Path, output_dir: Path, stack_size: int, remove_sources: bool) -> None:
    """Reads a TIFF stack and extracts its frames as LERC-compressed files.

    This is a worker function called by the _extract_frames_from_stack() as it parallelizes stack processing for each
    input directory. Specifically, this function is called for each stack inside each processed TIFF directory. It
    extracts each frame stored inside the input stack as a series of LERC-compressed TIFF files and verifies that each
    extracted frame matches the original to ensure data integrity.

    Raises:
        RuntimeError: If any extracted frame does not match the original frame stored inside the TIFF stack.

    Args:
        tiff_path: The path to the TIFF stack to process.
        output_dir: The path to the directory for the processed frames.
        stack_size: The size of each TIFF stack.
        remove_sources: Determines whether to remove original TIFF stacks after processing.
    """

    # Loads the stack into RAM
    img = tifffile.imread(str(tiff_path))

    # Uses the base stack name to compute the numeric ID for each frame. Specifically, uses the stack number and
    # the stack size parameters to determine the exact number of each extracted frame in the overall sequence saved
    # over multiple stacks.
    base_name = tiff_path.stem
    session_sequence: str = base_name.split("__")[-1]
    _, stack_number = session_sequence.split("_")
    previous_frames = (int(stack_number) - 1) * stack_size

    # Sequentially loops over each frame and extracts them as Tiffs.
    frame: np.ndarray[Any]
    for i, frame in enumerate(img, start=previous_frames + 1):
        output_path = output_dir.joinpath(f"{i:012d}.tiff")
        tifffile.imwrite(
            output_path,
            frame,
            compression='lerc',
            compressionargs={'level': 0.0},  # Lossless
            predictor=True,
            resolutionunit='NONE'  # Remove unnecessary metadata
        )

        # Loads the newly compressed frame and verifies that it matches the original frame
        new_frame = tifffile.imread(str(output_path))
        if not np.array_equal(new_frame, frame):
            message = f"Frame {i} does not match the original frame in {tiff_path}."
            console.error(message=message, error=RuntimeError)

    # Since the integrity of each extracted frame is verified above, it is always safe to remove the original tiff file
    if remove_sources:
        tiff_path.unlink()  # Removes the original tiff file after it has been processed


def extract_frames_from_stack(image_directory: Path, num_processes: int,
                              remove_sources: bool = False, batch: bool = False) -> None:
    """Loops over all multi-frame TIFF stacks in the input directory and extracts individual frames as efficiently
    compressed TIFF files.

    This function is used as a preprocessing step for mesoscope-acquired data, preparing it to be further processed
    via suite2p. In addition to extracting data as single frame tiffs, it also compresses each tiff with an
    efficient 'LERC' scheme and removes unnecessary tiff metadata and source stacks. These steps achieve ~70%
    compression ratio, compared to the original frame stacks obtained from the mesoscope.

    Notes:
        This function is specifically calibrated to work with TIFF stacks produced by the scanimage matlab software.
        Critically, these stacks are named using '__' to separate session and stack number from the rest of the
        file name, and the stack number is always found last, e.g.: 'Tyche-A7_2022_01_25_1__00001_00067.tif'. If the
        input TIFF files do not follow this naming convention, the function will not work as expected.

        This function assumes that scanimage buffers frames until the stack_size number of frames is available and then
        saves the frames as a TIFF stack. Therefore, it assumes that the directory contains at most one non-full stack.
        The function uses this assumption when assigning unique frame IDs to extracted frames.

        To optimize runtime efficiency, this function employs multiple processes to work with multiple TIFF at the
        same time. It uses the stack number and stack size as a heuristic to determine which IDs to assign to each
        extracted frame while processing stacks in-parallel to avoid collisions.

    Args:
        image_directory: The directory containing the multi-frame TIFF stacks.
        num_processes: The maximum number of processes to use while processing the directory.
        remove_sources: Determines whether to remove the original TIFF files after they have been processed.
        batch: Determines whether the function is called as part of batch-processing multiple directories. This is used
            to optimize progress reporting to avoid cluttering the terminal.
    """
    # Generates a new 'mesoscope_frames' directory to store extracted .tiff frame files.
    output_dir = image_directory.joinpath("mesoscope_frames")
    ensure_directory_exists(output_dir)

    # Finds all TIFF files in the input directory (non-recursive).
    tiff_files = list(image_directory.glob("*.tif")) + list(image_directory.glob("*.tiff"))

    # Loops over each tiff stack and extracts the number of frames inside each stack. If the file is not a stack,
    # removes it from further processing.
    maximum_stack_size = 0
    for file in tiff_files:
        stack_size = _check_stack_size(file)

        if stack_size == 0:
            tiff_files.remove(file)  # Removes non-stack files from further processing

        # If any stack has a larger size than the current maximum, updates the maximum size
        if stack_size > maximum_stack_size:
            maximum_stack_size = stack_size

    # If there are TIFFs to process, executes frame extraction
    if len(tiff_files) > 0:
        # Uses partial to bind the constant arguments
        process_func = partial(_process_stack,
                               output_dir=output_dir,
                               stack_size=maximum_stack_size,
                               remove_sources=remove_sources)

        # Processes each tiff stack in parallel
        with ProcessPoolExecutor(max_workers=num_processes) as executor:
            # Submits all tasks
            future_to_file = {executor.submit(process_func, file): file for file in tiff_files}

            if not batch:
                # Shows progress with tqdm when not in batch mode
                with tqdm(total=len(tiff_files), desc="Processing TIFF stacks", unit="files") as pbar:
                    for future in as_completed(future_to_file):
                        future.result()  # Gets result to ensure completion
                        pbar.update(1)
            else:
                # For batch mode, processes without progress tracking
                [future.result() for future in as_completed(future_to_file)]